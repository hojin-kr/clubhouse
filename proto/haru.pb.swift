// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: haru.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Haru_AccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var registerTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_AccountReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var registerTimestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_ProfileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var nickname: String = String()

  var likes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_PlaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: String = String()

  var language: String = String()

  var placeID: String = String()

  var isVisit: Bool = false

  var isLike: Bool = false

  var location: String = String()

  var radius: UInt64 = 0

  var keyword: String = String()

  var pageToken: String = String()

  var openNow: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_ProfileReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var nickname: String = String()

  var likes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_PointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var point: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 서버 단독 Place 정보들 모델로 정의 포인트, 방문정보등
struct Haru_PointReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 = 0

  var point: Int64 = 0

  var count: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_PlaceReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var addressComponents: [Haru_AddressComponent] {
    get {return _storage._addressComponents}
    set {_uniqueStorage()._addressComponents = newValue}
  }

  var formattedAddress: String {
    get {return _storage._formattedAddress}
    set {_uniqueStorage()._formattedAddress = newValue}
  }

  var adrAddress: String {
    get {return _storage._adrAddress}
    set {_uniqueStorage()._adrAddress = newValue}
  }

  var formattedPhoneNumber: String {
    get {return _storage._formattedPhoneNumber}
    set {_uniqueStorage()._formattedPhoneNumber = newValue}
  }

  var internationalPhoneNumber: String {
    get {return _storage._internationalPhoneNumber}
    set {_uniqueStorage()._internationalPhoneNumber = newValue}
  }

  var geometry: Haru_AddressGeometry {
    get {return _storage._geometry ?? Haru_AddressGeometry()}
    set {_uniqueStorage()._geometry = newValue}
  }
  /// Returns true if `geometry` has been explicitly set.
  var hasGeometry: Bool {return _storage._geometry != nil}
  /// Clears the value of `geometry`. Subsequent reads from it will return its default value.
  mutating func clearGeometry() {_uniqueStorage()._geometry = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  var placeID: String {
    get {return _storage._placeID}
    set {_uniqueStorage()._placeID = newValue}
  }

  var rating: Float {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  var userRatingsTotal: Int64 {
    get {return _storage._userRatingsTotal}
    set {_uniqueStorage()._userRatingsTotal = newValue}
  }

  var types: [String] {
    get {return _storage._types}
    set {_uniqueStorage()._types = newValue}
  }

  var openingHours: Haru_OpeningHours {
    get {return _storage._openingHours ?? Haru_OpeningHours()}
    set {_uniqueStorage()._openingHours = newValue}
  }
  /// Returns true if `openingHours` has been explicitly set.
  var hasOpeningHours: Bool {return _storage._openingHours != nil}
  /// Clears the value of `openingHours`. Subsequent reads from it will return its default value.
  mutating func clearOpeningHours() {_uniqueStorage()._openingHours = nil}

  var photos: [Haru_Photo] {
    get {return _storage._photos}
    set {_uniqueStorage()._photos = newValue}
  }

  var priceLevel: Int64 {
    get {return _storage._priceLevel}
    set {_uniqueStorage()._priceLevel = newValue}
  }

  var vicinity: String {
    get {return _storage._vicinity}
    set {_uniqueStorage()._vicinity = newValue}
  }

  var permanentlyClosed: Bool {
    get {return _storage._permanentlyClosed}
    set {_uniqueStorage()._permanentlyClosed = newValue}
  }

  var businessStatus: String {
    get {return _storage._businessStatus}
    set {_uniqueStorage()._businessStatus = newValue}
  }

  var reviews: [Haru_PlaceReview] {
    get {return _storage._reviews}
    set {_uniqueStorage()._reviews = newValue}
  }

  var utcOffset: Int64 {
    get {return _storage._utcOffset}
    set {_uniqueStorage()._utcOffset = newValue}
  }

  var website: String {
    get {return _storage._website}
    set {_uniqueStorage()._website = newValue}
  }

  var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  var htmlAttributions: [String] {
    get {return _storage._htmlAttributions}
    set {_uniqueStorage()._htmlAttributions = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Haru_AddressComponent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longName: String = String()

  var shortName: String = String()

  var types: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_AddressGeometry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: Haru_LatLng {
    get {return _location ?? Haru_LatLng()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var locationType: String = String()

  var bounds: Haru_LatLngBounds {
    get {return _bounds ?? Haru_LatLngBounds()}
    set {_bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  var hasBounds: Bool {return self._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  mutating func clearBounds() {self._bounds = nil}

  var viewport: Haru_LatLngBounds {
    get {return _viewport ?? Haru_LatLngBounds()}
    set {_viewport = newValue}
  }
  /// Returns true if `viewport` has been explicitly set.
  var hasViewport: Bool {return self._viewport != nil}
  /// Clears the value of `viewport`. Subsequent reads from it will return its default value.
  mutating func clearViewport() {self._viewport = nil}

  var types: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: Haru_LatLng? = nil
  fileprivate var _bounds: Haru_LatLngBounds? = nil
  fileprivate var _viewport: Haru_LatLngBounds? = nil
}

struct Haru_LatLng {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Float = 0

  var lng: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_LatLngBounds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var northeast: Haru_LatLng {
    get {return _northeast ?? Haru_LatLng()}
    set {_northeast = newValue}
  }
  /// Returns true if `northeast` has been explicitly set.
  var hasNortheast: Bool {return self._northeast != nil}
  /// Clears the value of `northeast`. Subsequent reads from it will return its default value.
  mutating func clearNortheast() {self._northeast = nil}

  var southwest: Haru_LatLng {
    get {return _southwest ?? Haru_LatLng()}
    set {_southwest = newValue}
  }
  /// Returns true if `southwest` has been explicitly set.
  var hasSouthwest: Bool {return self._southwest != nil}
  /// Clears the value of `southwest`. Subsequent reads from it will return its default value.
  mutating func clearSouthwest() {self._southwest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _northeast: Haru_LatLng? = nil
  fileprivate var _southwest: Haru_LatLng? = nil
}

struct Haru_OpeningHoursOpenClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var day: Int64 = 0

  var time: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_Photo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var photoReference: String = String()

  var height: Int64 = 0

  var width: Int64 = 0

  var htmlAttributions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_PlaceReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var aspects: [Haru_PlaceReviewAspect] = []

  var authorName: String = String()

  var authorURL: String = String()

  var profilePhotoURL: String = String()

  var language: String = String()

  var rating: Int64 = 0

  var text: String = String()

  var time: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_PlaceReviewAspect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rating: Int64 = 0

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Haru_OpeningHours {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var openNow: Bool = false

  var periods: [Haru_OpeningHours.OpeningHoursPeriod] = []

  var weekdayText: [String] = []

  var permanentlyClosed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct OpeningHoursPeriod {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `open`: Haru_OpeningHours.OpeningHoursOpenClose {
      get {return _open ?? Haru_OpeningHours.OpeningHoursOpenClose()}
      set {_open = newValue}
    }
    /// Returns true if ``open`` has been explicitly set.
    var hasOpen: Bool {return self._open != nil}
    /// Clears the value of ``open``. Subsequent reads from it will return its default value.
    mutating func clearOpen() {self._open = nil}

    var close: Haru_OpeningHours.OpeningHoursOpenClose {
      get {return _close ?? Haru_OpeningHours.OpeningHoursOpenClose()}
      set {_close = newValue}
    }
    /// Returns true if `close` has been explicitly set.
    var hasClose: Bool {return self._close != nil}
    /// Clears the value of `close`. Subsequent reads from it will return its default value.
    mutating func clearClose() {self._close = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _open: Haru_OpeningHours.OpeningHoursOpenClose? = nil
    fileprivate var _close: Haru_OpeningHours.OpeningHoursOpenClose? = nil
  }

  struct OpeningHoursOpenClose {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var day: Int64 = 0

    var time: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Haru_PlaceProfileReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placeID: String = String()

  var popularTimes: [Haru_PlaceProfileReply.Populartimes] = []

  var likes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Populartimes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var weekday: Int64 = 0

    var time: Int64 = 0

    var count: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Haru_PlaceReplyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placeReplyList: [Haru_PlaceReply] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Haru_AccountRequest: @unchecked Sendable {}
extension Haru_AccountReply: @unchecked Sendable {}
extension Haru_ProfileRequest: @unchecked Sendable {}
extension Haru_PlaceRequest: @unchecked Sendable {}
extension Haru_ProfileReply: @unchecked Sendable {}
extension Haru_PointRequest: @unchecked Sendable {}
extension Haru_PointReply: @unchecked Sendable {}
extension Haru_PlaceReply: @unchecked Sendable {}
extension Haru_AddressComponent: @unchecked Sendable {}
extension Haru_AddressGeometry: @unchecked Sendable {}
extension Haru_LatLng: @unchecked Sendable {}
extension Haru_LatLngBounds: @unchecked Sendable {}
extension Haru_OpeningHoursOpenClose: @unchecked Sendable {}
extension Haru_Photo: @unchecked Sendable {}
extension Haru_PlaceReview: @unchecked Sendable {}
extension Haru_PlaceReviewAspect: @unchecked Sendable {}
extension Haru_OpeningHours: @unchecked Sendable {}
extension Haru_OpeningHours.OpeningHoursPeriod: @unchecked Sendable {}
extension Haru_OpeningHours.OpeningHoursOpenClose: @unchecked Sendable {}
extension Haru_PlaceProfileReply: @unchecked Sendable {}
extension Haru_PlaceProfileReply.Populartimes: @unchecked Sendable {}
extension Haru_PlaceReplyList: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "haru"

extension Haru_AccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "register_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.registerTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.registerTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.registerTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_AccountRequest, rhs: Haru_AccountRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.registerTimestamp != rhs.registerTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_AccountReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "register_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.registerTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.registerTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.registerTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_AccountReply, rhs: Haru_AccountReply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.registerTimestamp != rhs.registerTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_ProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nickname"),
    3: .same(proto: "likes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.likes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.likes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.likes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_ProfileRequest, rhs: Haru_ProfileRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.likes != rhs.likes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "language"),
    3: .standard(proto: "place_id"),
    4: .standard(proto: "is_visit"),
    5: .standard(proto: "is_like"),
    6: .same(proto: "location"),
    7: .same(proto: "radius"),
    8: .same(proto: "keyword"),
    9: .same(proto: "pageToken"),
    10: .same(proto: "OpenNow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.input) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.placeID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isVisit) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isLike) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.radius) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.openNow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.placeID.isEmpty {
      try visitor.visitSingularStringField(value: self.placeID, fieldNumber: 3)
    }
    if self.isVisit != false {
      try visitor.visitSingularBoolField(value: self.isVisit, fieldNumber: 4)
    }
    if self.isLike != false {
      try visitor.visitSingularBoolField(value: self.isLike, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if self.radius != 0 {
      try visitor.visitSingularUInt64Field(value: self.radius, fieldNumber: 7)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 8)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 9)
    }
    if self.openNow != false {
      try visitor.visitSingularBoolField(value: self.openNow, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceRequest, rhs: Haru_PlaceRequest) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.language != rhs.language {return false}
    if lhs.placeID != rhs.placeID {return false}
    if lhs.isVisit != rhs.isVisit {return false}
    if lhs.isLike != rhs.isLike {return false}
    if lhs.location != rhs.location {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.openNow != rhs.openNow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_ProfileReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nickname"),
    3: .same(proto: "likes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.likes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.likes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.likes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_ProfileReply, rhs: Haru_ProfileReply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.likes != rhs.likes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.point) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.point != 0 {
      try visitor.visitSingularInt64Field(value: self.point, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PointRequest, rhs: Haru_PointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.point != rhs.point {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PointReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "point"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.point) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.point != 0 {
      try visitor.visitSingularInt64Field(value: self.point, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PointReply, rhs: Haru_PointReply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.point != rhs.point {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_components"),
    2: .standard(proto: "formatted_address"),
    3: .standard(proto: "adr_address"),
    4: .standard(proto: "formatted_phone_number"),
    5: .standard(proto: "international_phone_number"),
    6: .same(proto: "geometry"),
    7: .same(proto: "name"),
    8: .same(proto: "icon"),
    9: .standard(proto: "place_id"),
    10: .same(proto: "rating"),
    11: .standard(proto: "user_ratings_total"),
    12: .same(proto: "Types"),
    13: .standard(proto: "opening_hours"),
    14: .same(proto: "photos"),
    15: .standard(proto: "price_level"),
    16: .same(proto: "vicinity"),
    17: .standard(proto: "permanently_closed"),
    18: .standard(proto: "business_status"),
    19: .same(proto: "reviews"),
    20: .standard(proto: "utc_offset"),
    21: .same(proto: "website"),
    22: .same(proto: "url"),
    23: .standard(proto: "html_attributions"),
  ]

  fileprivate class _StorageClass {
    var _addressComponents: [Haru_AddressComponent] = []
    var _formattedAddress: String = String()
    var _adrAddress: String = String()
    var _formattedPhoneNumber: String = String()
    var _internationalPhoneNumber: String = String()
    var _geometry: Haru_AddressGeometry? = nil
    var _name: String = String()
    var _icon: String = String()
    var _placeID: String = String()
    var _rating: Float = 0
    var _userRatingsTotal: Int64 = 0
    var _types: [String] = []
    var _openingHours: Haru_OpeningHours? = nil
    var _photos: [Haru_Photo] = []
    var _priceLevel: Int64 = 0
    var _vicinity: String = String()
    var _permanentlyClosed: Bool = false
    var _businessStatus: String = String()
    var _reviews: [Haru_PlaceReview] = []
    var _utcOffset: Int64 = 0
    var _website: String = String()
    var _url: String = String()
    var _htmlAttributions: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _addressComponents = source._addressComponents
      _formattedAddress = source._formattedAddress
      _adrAddress = source._adrAddress
      _formattedPhoneNumber = source._formattedPhoneNumber
      _internationalPhoneNumber = source._internationalPhoneNumber
      _geometry = source._geometry
      _name = source._name
      _icon = source._icon
      _placeID = source._placeID
      _rating = source._rating
      _userRatingsTotal = source._userRatingsTotal
      _types = source._types
      _openingHours = source._openingHours
      _photos = source._photos
      _priceLevel = source._priceLevel
      _vicinity = source._vicinity
      _permanentlyClosed = source._permanentlyClosed
      _businessStatus = source._businessStatus
      _reviews = source._reviews
      _utcOffset = source._utcOffset
      _website = source._website
      _url = source._url
      _htmlAttributions = source._htmlAttributions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._addressComponents) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._formattedAddress) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._adrAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._formattedPhoneNumber) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._internationalPhoneNumber) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._geometry) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._icon) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._placeID) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._rating) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._userRatingsTotal) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._types) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._openingHours) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._photos) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._priceLevel) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._vicinity) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._permanentlyClosed) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._businessStatus) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._reviews) }()
        case 20: try { try decoder.decodeSingularInt64Field(value: &_storage._utcOffset) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._website) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._htmlAttributions) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._addressComponents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._addressComponents, fieldNumber: 1)
      }
      if !_storage._formattedAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._formattedAddress, fieldNumber: 2)
      }
      if !_storage._adrAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._adrAddress, fieldNumber: 3)
      }
      if !_storage._formattedPhoneNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._formattedPhoneNumber, fieldNumber: 4)
      }
      if !_storage._internationalPhoneNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._internationalPhoneNumber, fieldNumber: 5)
      }
      try { if let v = _storage._geometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 7)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 8)
      }
      if !_storage._placeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._placeID, fieldNumber: 9)
      }
      if _storage._rating != 0 {
        try visitor.visitSingularFloatField(value: _storage._rating, fieldNumber: 10)
      }
      if _storage._userRatingsTotal != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userRatingsTotal, fieldNumber: 11)
      }
      if !_storage._types.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._types, fieldNumber: 12)
      }
      try { if let v = _storage._openingHours {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._photos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._photos, fieldNumber: 14)
      }
      if _storage._priceLevel != 0 {
        try visitor.visitSingularInt64Field(value: _storage._priceLevel, fieldNumber: 15)
      }
      if !_storage._vicinity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vicinity, fieldNumber: 16)
      }
      if _storage._permanentlyClosed != false {
        try visitor.visitSingularBoolField(value: _storage._permanentlyClosed, fieldNumber: 17)
      }
      if !_storage._businessStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._businessStatus, fieldNumber: 18)
      }
      if !_storage._reviews.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reviews, fieldNumber: 19)
      }
      if _storage._utcOffset != 0 {
        try visitor.visitSingularInt64Field(value: _storage._utcOffset, fieldNumber: 20)
      }
      if !_storage._website.isEmpty {
        try visitor.visitSingularStringField(value: _storage._website, fieldNumber: 21)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 22)
      }
      if !_storage._htmlAttributions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._htmlAttributions, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceReply, rhs: Haru_PlaceReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._addressComponents != rhs_storage._addressComponents {return false}
        if _storage._formattedAddress != rhs_storage._formattedAddress {return false}
        if _storage._adrAddress != rhs_storage._adrAddress {return false}
        if _storage._formattedPhoneNumber != rhs_storage._formattedPhoneNumber {return false}
        if _storage._internationalPhoneNumber != rhs_storage._internationalPhoneNumber {return false}
        if _storage._geometry != rhs_storage._geometry {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._placeID != rhs_storage._placeID {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._userRatingsTotal != rhs_storage._userRatingsTotal {return false}
        if _storage._types != rhs_storage._types {return false}
        if _storage._openingHours != rhs_storage._openingHours {return false}
        if _storage._photos != rhs_storage._photos {return false}
        if _storage._priceLevel != rhs_storage._priceLevel {return false}
        if _storage._vicinity != rhs_storage._vicinity {return false}
        if _storage._permanentlyClosed != rhs_storage._permanentlyClosed {return false}
        if _storage._businessStatus != rhs_storage._businessStatus {return false}
        if _storage._reviews != rhs_storage._reviews {return false}
        if _storage._utcOffset != rhs_storage._utcOffset {return false}
        if _storage._website != rhs_storage._website {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._htmlAttributions != rhs_storage._htmlAttributions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_AddressComponent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressComponent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "long_name"),
    2: .standard(proto: "short_name"),
    3: .same(proto: "types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 1)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 2)
    }
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_AddressComponent, rhs: Haru_AddressComponent) -> Bool {
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_AddressGeometry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressGeometry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .standard(proto: "location_type"),
    3: .same(proto: "bounds"),
    4: .same(proto: "viewport"),
    5: .same(proto: "types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.locationType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bounds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._viewport) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.locationType.isEmpty {
      try visitor.visitSingularStringField(value: self.locationType, fieldNumber: 2)
    }
    try { if let v = self._bounds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._viewport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_AddressGeometry, rhs: Haru_AddressGeometry) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.locationType != rhs.locationType {return false}
    if lhs._bounds != rhs._bounds {return false}
    if lhs._viewport != rhs._viewport {return false}
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_LatLng: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LatLng"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lng"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.lng) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularFloatField(value: self.lat, fieldNumber: 1)
    }
    if self.lng != 0 {
      try visitor.visitSingularFloatField(value: self.lng, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_LatLng, rhs: Haru_LatLng) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lng != rhs.lng {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_LatLngBounds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LatLngBounds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "northeast"),
    2: .same(proto: "southwest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._northeast) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._southwest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._northeast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._southwest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_LatLngBounds, rhs: Haru_LatLngBounds) -> Bool {
    if lhs._northeast != rhs._northeast {return false}
    if lhs._southwest != rhs._southwest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_OpeningHoursOpenClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpeningHoursOpenClose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.day) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != 0 {
      try visitor.visitSingularInt64Field(value: self.day, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_OpeningHoursOpenClose, rhs: Haru_OpeningHoursOpenClose) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_Photo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Photo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_reference"),
    2: .same(proto: "height"),
    3: .same(proto: "width"),
    4: .standard(proto: "html_attributions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.photoReference) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.width) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.htmlAttributions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.photoReference.isEmpty {
      try visitor.visitSingularStringField(value: self.photoReference, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 3)
    }
    if !self.htmlAttributions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.htmlAttributions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_Photo, rhs: Haru_Photo) -> Bool {
    if lhs.photoReference != rhs.photoReference {return false}
    if lhs.height != rhs.height {return false}
    if lhs.width != rhs.width {return false}
    if lhs.htmlAttributions != rhs.htmlAttributions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aspects"),
    2: .standard(proto: "author_name"),
    3: .standard(proto: "author_url"),
    4: .standard(proto: "profile_photo_url"),
    5: .same(proto: "language"),
    6: .same(proto: "rating"),
    7: .same(proto: "text"),
    8: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aspects) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.profilePhotoURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.rating) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aspects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aspects, fieldNumber: 1)
    }
    if !self.authorName.isEmpty {
      try visitor.visitSingularStringField(value: self.authorName, fieldNumber: 2)
    }
    if !self.authorURL.isEmpty {
      try visitor.visitSingularStringField(value: self.authorURL, fieldNumber: 3)
    }
    if !self.profilePhotoURL.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePhotoURL, fieldNumber: 4)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    if self.rating != 0 {
      try visitor.visitSingularInt64Field(value: self.rating, fieldNumber: 6)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 7)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceReview, rhs: Haru_PlaceReview) -> Bool {
    if lhs.aspects != rhs.aspects {return false}
    if lhs.authorName != rhs.authorName {return false}
    if lhs.authorURL != rhs.authorURL {return false}
    if lhs.profilePhotoURL != rhs.profilePhotoURL {return false}
    if lhs.language != rhs.language {return false}
    if lhs.rating != rhs.rating {return false}
    if lhs.text != rhs.text {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceReviewAspect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceReviewAspect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rating"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rating) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rating != 0 {
      try visitor.visitSingularInt64Field(value: self.rating, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceReviewAspect, rhs: Haru_PlaceReviewAspect) -> Bool {
    if lhs.rating != rhs.rating {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_OpeningHours: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpeningHours"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_now"),
    2: .same(proto: "periods"),
    3: .standard(proto: "weekday_text"),
    4: .standard(proto: "permanently_closed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.openNow) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.periods) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.weekdayText) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.permanentlyClosed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.openNow != false {
      try visitor.visitSingularBoolField(value: self.openNow, fieldNumber: 1)
    }
    if !self.periods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.periods, fieldNumber: 2)
    }
    if !self.weekdayText.isEmpty {
      try visitor.visitRepeatedStringField(value: self.weekdayText, fieldNumber: 3)
    }
    if self.permanentlyClosed != false {
      try visitor.visitSingularBoolField(value: self.permanentlyClosed, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_OpeningHours, rhs: Haru_OpeningHours) -> Bool {
    if lhs.openNow != rhs.openNow {return false}
    if lhs.periods != rhs.periods {return false}
    if lhs.weekdayText != rhs.weekdayText {return false}
    if lhs.permanentlyClosed != rhs.permanentlyClosed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_OpeningHours.OpeningHoursPeriod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Haru_OpeningHours.protoMessageName + ".OpeningHoursPeriod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "close"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._close) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._close {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_OpeningHours.OpeningHoursPeriod, rhs: Haru_OpeningHours.OpeningHoursPeriod) -> Bool {
    if lhs._open != rhs._open {return false}
    if lhs._close != rhs._close {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_OpeningHours.OpeningHoursOpenClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Haru_OpeningHours.protoMessageName + ".OpeningHoursOpenClose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.day) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != 0 {
      try visitor.visitSingularInt64Field(value: self.day, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_OpeningHours.OpeningHoursOpenClose, rhs: Haru_OpeningHours.OpeningHoursOpenClose) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceProfileReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceProfileReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "place_id"),
    2: .standard(proto: "popular_times"),
    3: .same(proto: "likes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.placeID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.popularTimes) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.likes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.placeID.isEmpty {
      try visitor.visitSingularStringField(value: self.placeID, fieldNumber: 1)
    }
    if !self.popularTimes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.popularTimes, fieldNumber: 2)
    }
    if self.likes != 0 {
      try visitor.visitSingularInt64Field(value: self.likes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceProfileReply, rhs: Haru_PlaceProfileReply) -> Bool {
    if lhs.placeID != rhs.placeID {return false}
    if lhs.popularTimes != rhs.popularTimes {return false}
    if lhs.likes != rhs.likes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceProfileReply.Populartimes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Haru_PlaceProfileReply.protoMessageName + ".Populartimes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weekday"),
    2: .same(proto: "time"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.weekday) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weekday != 0 {
      try visitor.visitSingularInt64Field(value: self.weekday, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceProfileReply.Populartimes, rhs: Haru_PlaceProfileReply.Populartimes) -> Bool {
    if lhs.weekday != rhs.weekday {return false}
    if lhs.time != rhs.time {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Haru_PlaceReplyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaceReplyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "place_reply_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.placeReplyList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.placeReplyList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.placeReplyList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Haru_PlaceReplyList, rhs: Haru_PlaceReplyList) -> Bool {
    if lhs.placeReplyList != rhs.placeReplyList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
